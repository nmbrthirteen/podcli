<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>podcli — Knowledge Base</title>
  <link rel="icon" type="image/png" href="/podcli-icon-transparent.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <link rel="stylesheet" href="css/styles.css">
  <style>
    .app { max-width: 860px; }
    .header { margin-bottom: 32px; }
    .drop-zone { padding: 36px 24px; margin-bottom: 24px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    function App() {
      const [files, setFiles] = useState([]);
      const [activeFile, setActiveFile] = useState(null);
      const [editorContent, setEditorContent] = useState('');
      const [dirty, setDirty] = useState(false);
      const [dragOver, setDragOver] = useState(false);
      const [toast, setToast] = useState(null);
      const [newName, setNewName] = useState('');
      const [kbDir, setKbDir] = useState('');

      const showToast = (msg) => { setToast(msg); setTimeout(() => setToast(null), 2000); };

      const loadFiles = useCallback(async () => {
        const data = await (await fetch('/api/knowledge')).json();
        setFiles(data);
      }, []);

      useEffect(() => {
        loadFiles();
        fetch('/api/knowledge/dir').then(r => r.json()).then(d => setKbDir(d.path)).catch(() => {});
      }, []);

      const openFile = (f) => {
        if (dirty && !confirm('Discard unsaved changes?')) return;
        setActiveFile(f.filename);
        setEditorContent(f.content);
        setDirty(false);
      };

      const saveFile = async () => {
        if (!activeFile) return;
        await fetch(`/api/knowledge/${encodeURIComponent(activeFile)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: editorContent }),
        });
        setDirty(false);
        showToast('Saved');
        loadFiles();
      };

      const deleteFile = async (filename, e) => {
        e.stopPropagation();
        if (!confirm(`Delete ${filename}?`)) return;
        await fetch(`/api/knowledge/${encodeURIComponent(filename)}`, { method: 'DELETE' });
        if (activeFile === filename) { setActiveFile(null); setEditorContent(''); }
        showToast('Deleted');
        loadFiles();
      };

      const createFile = async () => {
        let name = newName.trim();
        if (!name) return;
        if (!name.endsWith('.md')) name += '.md';
        await fetch(`/api/knowledge/${encodeURIComponent(name)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: `# ${name.replace('.md', '')}\n\n` }),
        });
        setNewName('');
        await loadFiles();
        // Open the new file
        const data = await (await fetch('/api/knowledge')).json();
        const created = data.find(f => f.filename === name);
        if (created) openFile(created);
        showToast('Created');
      };

      const handleDrop = async (e) => {
        e.preventDefault();
        setDragOver(false);
        const dt = e.dataTransfer;
        if (!dt.files.length) return;
        const fd = new FormData();
        for (const f of dt.files) {
          if (f.name.endsWith('.md') || f.name.endsWith('.txt')) fd.append('files', f);
        }
        if (!fd.has('files')) return;
        await fetch('/api/knowledge/upload', { method: 'POST', body: fd });
        showToast(`${dt.files.length} file(s) added`);
        loadFiles();
      };

      const handleFileInput = async (e) => {
        const inputFiles = e.target.files;
        if (!inputFiles.length) return;
        const fd = new FormData();
        for (const f of inputFiles) fd.append('files', f);
        await fetch('/api/knowledge/upload', { method: 'POST', body: fd });
        showToast(`${inputFiles.length} file(s) added`);
        loadFiles();
        e.target.value = '';
      };

      const realFiles = files.filter(f => f.filename !== 'README.md');

      return (
        <div className="app">
          <div className="nav">
            <a href="/"><img src="/podcli-logo-transparent.png" alt="podcli" style={{ height: 22 }} /></a>
            <a href="/" className="nav-link">Back to app</a>
          </div>

          <div className="header">
            <h1>Knowledge Base</h1>
            <p className="subtitle">
              Add .md files to give the AI context about your podcast — hosts, style preferences, audience, topics to avoid.
              The MCP server reads these before every request.
            </p>
            {kbDir && <div className="dir-path">{kbDir}</div>}
          </div>

          {/* Drop zone */}
          <div
            className={`drop-zone ${dragOver ? 'drag-over' : ''}`}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onDrop={handleDrop}
          >
            <div className="dz-icon">{'\uD83D\uDCC4'}</div>
            <div className="dz-text">
              Drop <strong>.md files</strong> here or click to browse
            </div>
            <input type="file" accept=".md,.txt" multiple onChange={handleFileInput} />
          </div>

          {/* File grid */}
          {realFiles.length > 0 ? (
            <div className="file-grid">
              {realFiles.map(f => (
                <div
                  key={f.filename}
                  className={`file-card ${activeFile === f.filename ? 'active' : ''}`}
                  onClick={() => openFile(f)}
                >
                  <button className="file-delete" onClick={(e) => deleteFile(f.filename, e)}>{'\u00D7'}</button>
                  <div className="file-name">{f.filename}</div>
                  <div className="file-meta">{new Date(f.updatedAt).toLocaleDateString()}</div>
                  <div className="file-preview">{f.content.split('\n').filter(l => l.trim() && !l.startsWith('#')).slice(0,2).join(' ')}</div>
                </div>
              ))}
            </div>
          ) : (
            <div className="empty-state">
              No knowledge files yet. Drop .md files above or create one below.
            </div>
          )}

          {/* New file */}
          <div className="new-file-row">
            <input
              className="new-file-input"
              placeholder="new-file-name.md"
              value={newName}
              onChange={e => setNewName(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && createFile()}
            />
            <button className="btn btn-primary" onClick={createFile}>Create</button>
          </div>

          {/* Editor */}
          {activeFile && (
            <div className="editor-panel" style={{ animation: 'fadeIn 0.2s var(--ease)' }}>
              <div className="editor-header">
                <span className="editor-filename">{activeFile}</span>
                <div className="editor-actions">
                  {dirty && <span style={{ fontSize: 11, color: 'var(--accent)', fontWeight: 600, padding: '4px 8px' }}>unsaved</span>}
                  <button className="btn btn-ghost" onClick={() => { setActiveFile(null); setEditorContent(''); setDirty(false); }}>Close</button>
                  <button className="btn btn-primary" onClick={saveFile}>Save</button>
                </div>
              </div>
              <textarea
                className="editor-textarea"
                value={editorContent}
                onChange={e => { setEditorContent(e.target.value); setDirty(true); }}
              />
            </div>
          )}

          {toast && <div className="toast">{toast}</div>}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>

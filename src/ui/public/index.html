<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>podcli</title>
  <link rel="icon" type="image/png" href="/podcli-icon-transparent.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const fmt = (s) => `${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}`;
    const api = async (path, opts={}) => (await fetch(`/api${path}`, { headers:{'Content-Type':'application/json',...opts.headers}, ...opts })).json();

    function uploadFile(file, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const fd = new FormData();
        fd.append('file', file);
        xhr.upload.onprogress = (e) => { if (e.lengthComputable && onProgress) onProgress(Math.round((e.loaded / e.total) * 100)); };
        xhr.onload = () => { try { resolve(JSON.parse(xhr.responseText)); } catch(e) { reject(e); } };
        xhr.onerror = () => reject(new Error('Upload failed'));
        xhr.open('POST', '/api/upload');
        xhr.send(fd);
      });
    }

    function useJob(jobId) {
      const [state, setState] = useState(null);
      useEffect(() => {
        if (!jobId) { setState(null); return; }
        const es = new EventSource(`/api/job/${jobId}/stream`);
        es.onmessage = e => { const d=JSON.parse(e.data); setState(d); if(d.status==='done'||d.status==='error') es.close(); };
        es.onerror = () => es.close();
        return () => es.close();
      }, [jobId]);
      return state;
    }

    // --- MCP ↔ UI Bridge: SSE hook ---
    function useSSE() {
      const [lastEvent, setLastEvent] = useState(null);
      const [connected, setConnected] = useState(false);
      useEffect(() => {
        const es = new EventSource('/api/events');
        const handle = (type) => (e) => {
          try { setLastEvent({ type, data: JSON.parse(e.data), ts: Date.now() }); } catch {}
        };
        es.addEventListener('state', (e) => { setConnected(true); handle('state')(e); });
        es.addEventListener('state-sync', handle('state-sync'));
        es.addEventListener('export-started', handle('export-started'));
        es.addEventListener('job-update', handle('job-update'));
        es.addEventListener('job-complete', handle('job-complete'));
        es.addEventListener('job-error', handle('job-error'));
        es.onerror = () => {};
        return () => es.close();
      }, []);
      return { lastEvent, connected };
    }

    const CheckIcon = () => (<svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M2.5 6L5 8.5L9.5 3.5" stroke="#fff" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/></svg>);
    const CheckSmall = ({ color = 'var(--green)' }) => (<svg width="10" height="10" viewBox="0 0 12 12" fill="none"><path d="M2.5 6L5 8.5L9.5 3.5" stroke={color} strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"/></svg>);

    /* ── Style Preview Component ── */
    const STYLE_CONFIGS = {
      branded: {
        words: ['Did you ever,', 'felt', 'like I\u2019m in the', 'wrong place'],
        fontSize: 19, fontWeight: 800, bottom: '30%',
        lineHeight: 1.3, textShadow: 'none',
        activeStyle: { background:'#1a1a1a', borderRadius:5, padding:'2px 6px', color:'#fff' },
        normalStyle: { background:'transparent', borderRadius:5, padding:'2px 6px', color:'#fff' },
        gradient: true,
      },
      hormozi: {
        words: ['LOOKING', 'FOR', 'HIGH ENERGY'],
        fontSize: 22, fontWeight: 900, bottom: '22%',
        lineHeight: 1.25, textShadow: '0 2px 8px rgba(0,0,0,0.7)',
        activeStyle: { color:'#ffff00' },
        normalStyle: { color:'#fff' },
        gradient: false,
      },
      karaoke: {
        words: ['the secret to', 'building', 'something', 'people', 'actually want'],
        fontSize: 15, fontWeight: 600, bottom: '22%',
        lineHeight: 1.4, textShadow: '0 1px 6px rgba(0,0,0,0.6)',
        activeStyle: { color:'#fff' },
        normalStyle: { color:'rgba(255,255,255,0.35)' },
        gradient: false,
      },
      subtle: {
        words: ['the secret to building something people actually want'],
        fontSize: 13, fontWeight: 400, bottom: '12%',
        lineHeight: 1.5, textShadow: '0 1px 4px rgba(0,0,0,0.8)',
        activeStyle: { color:'rgba(255,255,255,0.9)' },
        normalStyle: { color:'rgba(255,255,255,0.9)' },
        gradient: false,
      },
    };

    function StylePreview({ style, logoPath }) {
      const [activeIdx, setActiveIdx] = useState(0);
      const cfg = STYLE_CONFIGS[style] || STYLE_CONFIGS.branded;

      useEffect(() => {
        if (cfg.words.length <= 1) return;
        const iv = setInterval(() => setActiveIdx(i => (i + 1) % cfg.words.length), 800);
        return () => clearInterval(iv);
      }, [style]);

      useEffect(() => setActiveIdx(0), [style]);

      const showLogo = style === 'branded' && logoPath;

      return (
        <div className="style-preview fade-in" key={style}>
          <div className="sp-bg" />
          <div className="sp-person" />
          {cfg.gradient && <div className="sp-gradient" />}
          {showLogo && (
            <div className="sp-logo">
              <img src={`/api/stream-source?path=${encodeURIComponent(logoPath)}`} style={{ width:'100%', height:'100%', objectFit:'contain', borderRadius:6 }} />
            </div>
          )}
          <div className="sp-captions" style={{ bottom: cfg.bottom, fontSize: cfg.fontSize, fontWeight: cfg.fontWeight, lineHeight: cfg.lineHeight, textShadow: cfg.textShadow }}>
            <div style={{ display:'flex', flexWrap:'wrap', justifyContent:'center', gap:'4px 6px' }}>
              {cfg.words.map((w, i) => (
                <span key={w} className="sp-word" style={i === activeIdx ? cfg.activeStyle : cfg.normalStyle}>{w}</span>
              ))}
            </div>
          </div>
        </div>
      );
    }

    /* ── MCP Hints Component ── */
    function McpHints({ phase, videoPath, transcript, transcriptText, suggestions, mcpConnected }) {
      const [hints, setHints] = useState([]);
      const [copied, setCopied] = useState(null);
      const [collapsed, setCollapsed] = useState(false);

      // Fetch hints whenever state changes
      useEffect(() => {
        if (!mcpConnected) return;
        fetch('/api/mcp-hints').then(r => r.json()).then(d => {
          if (d.hints) setHints(d.hints);
        }).catch(() => {});
      }, [phase, videoPath, !!transcript, !!transcriptText, suggestions?.length, mcpConnected]);

      const copyPrompt = (prompt, idx) => {
        navigator.clipboard.writeText(prompt).then(() => {
          setCopied(idx);
          setTimeout(() => setCopied(null), 1500);
        }).catch(() => {});
      };

      // Only show when MCP is connected AND there are actionable hints
      if (!mcpConnected || hints.length === 0) return null;

      return (
        <div className="mcp-hints">
          <div className="mcp-hints-header" style={{cursor:'pointer'}} onClick={() => setCollapsed(!collapsed)}>
            <div className="mcp-hints-icon">AI</div>
            <div className="mcp-hints-title">MCP Prompts</div>
            <div className="mcp-hints-subtitle">
              {collapsed ? `${hints.length} prompts` : 'click to copy'}
            </div>
            <span style={{fontSize:10,color:'var(--text3)',transition:'transform 0.2s',transform:collapsed?'rotate(-90deg)':'rotate(0)',marginLeft:4}}>{'\u25BC'}</span>
          </div>
          {!collapsed && (
            <div className="mcp-hint-list">
              {hints.slice(0, 5).map((hint, i) => (
                <div key={i}
                  className={`mcp-hint ${copied === i ? 'copied' : ''}`}
                  onClick={() => copyPrompt(hint.prompt, i)}>
                  <span className={`mcp-hint-category ${hint.category}`}>{hint.category}</span>
                  <span className="mcp-hint-prompt">
                    {copied === i ? 'Copied!' : hint.prompt}
                  </span>
                  <span className="mcp-hint-desc">{hint.description}</span>
                  <button className="mcp-hint-copy" onClick={e => { e.stopPropagation(); copyPrompt(hint.prompt, i); }} title="Copy prompt">
                    {copied === i ? '\u2713' : '\u2398'}
                  </button>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    function App() {
      const [videoPath, setVideoPath] = useState('');
      const [transcriptMode, setTranscriptMode] = useState('import');
      const [transcriptText, setTranscriptText] = useState('');
      const [timeAdjust, setTimeAdjust] = useState(-1);
      const [whisperModel, setWhisperModel] = useState('base');
      const [captionStyle, setCaptionStyle] = useState('branded');
      const [cropStrategy, setCropStrategy] = useState('face');
      const [logoPath, setLogoPath] = useState('');
      const logoRef = useRef();
      const [outroPath, setOutroPath] = useState('');
      const initializedRef = useRef(false);
      const outroRef = useRef();
      const [outroUploading, setOutroUploading] = useState(false);
      const [transcriptDragOver, setTranscriptDragOver] = useState(false);
      const [transcriptFileName, setTranscriptFileName] = useState('');

      const [phase, setPhase] = useState('idle');
      const [file, setFile] = useState(null);
      const [transcript, setTranscript] = useState(null);
      const [suggestions, setSuggestions] = useState([]);
      const [deselected, setDeselected] = useState(new Set());
      const [batchJobId, setBatchJobId] = useState(null);
      const batchStream = useJob(batchJobId);
      const [results, setResults] = useState([]);
      const [error, setError] = useState(null);
      const [previewFile, setPreviewFile] = useState(null);

      const [retryIdx, setRetryIdx] = useState(null);
      const [retryJobId, setRetryJobId] = useState(null);
      const retryStream = useJob(retryJobId);

      const [logoUploading, setLogoUploading] = useState(false);
      const [browsing, setBrowsing] = useState(false);
      const [clipHistory, setClipHistory] = useState([]);
      const [historyOpen, setHistoryOpen] = useState(false);

      const [encoderInfo, setEncoderInfo] = useState(null);
      const [generateCopied, setGenerateCopied] = useState(false);
      useEffect(() => { api('/encoder-info').then(d => { if(d.best) setEncoderInfo(d); }).catch(()=>{}); }, []);

      // Fetch clip history on mount and after exports
      const fetchHistory = () => { fetch('/api/history?limit=50').then(r=>r.json()).then(d=>{ if(Array.isArray(d)) setClipHistory(d); }).catch(()=>{}); };
      useEffect(fetchHistory, []);
      useEffect(() => { if (phase === 'done') fetchHistory(); }, [phase]);

      // --- MCP ↔ UI Bridge: connect SSE + sync state ---
      const { lastEvent: sseEvent, connected: mcpConnected } = useSSE();

      // Sync UI state to server on changes (fire-and-forget)
      // Guard: don't sync until initial SSE state has been received to avoid overwriting persisted state with defaults
      const prevSyncRef = useRef('');
      useEffect(() => {
        if (!initializedRef.current) return;
        const state = {
          _source: 'ui',
          videoPath,
          filePath: file?.file_path || '',
          suggestions,
          deselectedIndices: Array.from(deselected),
          settings: { captionStyle, cropStrategy, logoPath, outroPath },
          phase,
        };
        const key = JSON.stringify(state);
        if (key === prevSyncRef.current) return;
        prevSyncRef.current = key;
        fetch('/api/ui-state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: key }).catch(() => {});
      }, [videoPath, file, suggestions, deselected, captionStyle, cropStrategy, logoPath, outroPath, phase]);

      // Sync transcript separately (large payload)
      const prevTranscriptRef = useRef(null);
      useEffect(() => {
        if (!initializedRef.current) return;
        if (!transcript || transcript === prevTranscriptRef.current) return;
        prevTranscriptRef.current = transcript;
        fetch('/api/ui-state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ _source: 'ui', transcript }) }).catch(() => {});
      }, [transcript]);

      // Sync raw transcript text so MCP can read it before pipeline runs
      const prevRawRef = useRef('');
      useEffect(() => {
        if (!initializedRef.current) return;
        if (transcriptText === prevRawRef.current) return;
        prevRawRef.current = transcriptText;
        if (transcriptText.trim()) {
          fetch('/api/ui-state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ _source: 'ui', rawTranscriptText: transcriptText }) }).catch(() => {});
        }
      }, [transcriptText]);

      // React to SSE events from MCP
      const lastHandledTsRef = useRef(0);
      useEffect(() => {
        if (!sseEvent || sseEvent.ts === lastHandledTsRef.current) return;
        lastHandledTsRef.current = sseEvent.ts;

        if (sseEvent.type === 'state-sync' || sseEvent.type === 'state') {
          const d = sseEvent.data;
          if (d.suggestions) setSuggestions(d.suggestions);
          if (d.deselectedIndices !== undefined) setDeselected(new Set(d.deselectedIndices));
          else if (d.suggestions && !d.deselectedIndices) setDeselected(new Set());
          if (d.phase) setPhase(d.phase);
          if (d.videoPath !== undefined) setVideoPath(d.videoPath);
          if (d.transcript) setTranscript(d.transcript);
          if (d.rawTranscriptText && !transcript) setTranscriptText(d.rawTranscriptText);
          if (d.settings) {
            if (d.settings.captionStyle) setCaptionStyle(d.settings.captionStyle);
            if (d.settings.cropStrategy) setCropStrategy(d.settings.cropStrategy);
            if (d.settings.logoPath !== undefined) setLogoPath(d.settings.logoPath);
            if (d.settings.outroPath !== undefined) setOutroPath(d.settings.outroPath);
          }
          // Mark initialized after first state restoration so sync useEffects don't overwrite with defaults
          if (sseEvent.type === 'state') {
            initializedRef.current = true;
          }
        } else if (sseEvent.type === 'export-started') {
          setBatchJobId(sseEvent.data.jobId);
          setPhase('exporting');
        } else if (sseEvent.type === 'job-complete') {
          if (phase === 'exporting' || sseEvent.data.result?.results) {
            setPhase('done');
            setResults(sseEvent.data.result?.results || []);
          }
        } else if (sseEvent.type === 'job-error') {
          if (phase === 'exporting') {
            setError('Export failed: ' + (sseEvent.data.error || 'Unknown error'));
            setPhase('review');
          }
        }
      }, [sseEvent]);

      // Preview panel state
      const videoRef = useRef();
      const [activeClipIdx, setActiveClipIdx] = useState(null);
      const [previewSrc, setPreviewSrc] = useState(null); // null=source, string=rendered clip filename
      const [settingsFlash, setSettingsFlash] = useState(null);

      // Video source URL
      const videoUrl = previewSrc
        ? `/api/preview/${previewSrc}`
        : videoPath
          ? `/api/stream-source?path=${encodeURIComponent(videoPath)}`
          : null;

      // Seek to clip when active clip changes (and showing source)
      useEffect(() => {
        if (activeClipIdx === null || previewSrc) return;
        const clip = suggestions[activeClipIdx];
        if (!clip || !videoRef.current) return;
        const seek = () => {
          videoRef.current.currentTime = clip.start_second;
          videoRef.current.play().catch(() => {});
        };
        if (videoRef.current.readyState >= 1) seek();
        else videoRef.current.addEventListener('loadedmetadata', seek, { once: true });
      }, [activeClipIdx, previewSrc]);

      // Flash settings when they change
      const flashSetting = (key) => {
        setSettingsFlash(key);
        setTimeout(() => setSettingsFlash(null), 600);
      };

      const onCaptionChange = (v) => { setCaptionStyle(v); flashSetting('caption'); };
      const onCropChange = (v) => { setCropStrategy(v); flashSetting('crop'); };

      // Click clip row → seek source video
      const onClipClick = (idx) => {
        setActiveClipIdx(idx);
        if (previewSrc) setPreviewSrc(null);
      };

      // Play rendered clip in preview panel
      const onPlayRendered = (filename) => {
        setPreviewSrc(filename);
        setActiveClipIdx(null);
      };

      // Native file browse
      const doBrowse = useCallback(async () => {
        setBrowsing(true);
        try {
          const d = await api('/browse-file');
          if (d.file_path) setVideoPath(d.file_path);
        } catch(e) { setError('Browse failed: ' + e.message); }
        finally { setBrowsing(false); }
      }, []);

      const startExport = async () => {
        setPhase('exporting'); setResults([]);
        const sc = suggestions.filter((_,i) => !deselected.has(i));
        const vp = file?.file_path || videoPath.trim();
        const data = await api('/batch-clips', { method:'POST', body: JSON.stringify({
          video_path: vp,
          clips: sc.map(c => ({ start_second: c.start_second, end_second: c.end_second, title: c.title.slice(0,40), caption_style: captionStyle, crop_strategy: cropStrategy })),
          transcript_words: transcript?.words || [], logo_path: logoPath || undefined, outro_path: outroPath || undefined,
        })});
        setBatchJobId(data.job_id);
      };

      useEffect(() => {
        if (batchStream?.status === 'done') { setPhase('done'); setResults(batchStream.result?.results || []); }
        if (batchStream?.status === 'error') { setError('Export failed: ' + batchStream.error); setPhase('review'); }
      }, [batchStream?.status]);

      const retryClip = async (idx) => {
        const sc = suggestions.filter((_,i) => !deselected.has(i));
        const c = sc[idx]; setRetryIdx(idx); setRetryJobId(null);
        const vp = file?.file_path || videoPath.trim();
        const data = await api('/create-clip', { method:'POST', body: JSON.stringify({
          video_path: vp, start_second: c.start_second, end_second: c.end_second,
          title: c.title.slice(0,40), caption_style: captionStyle, crop_strategy: cropStrategy,
          transcript_words: transcript?.words || [], logo_path: logoPath || undefined, outro_path: outroPath || undefined,
        })});
        setRetryJobId(data.job_id);
      };

      useEffect(() => {
        if (retryStream?.status === 'done') {
          setResults(prev => { const n = [...prev]; n[retryIdx] = { ...retryStream.result, status: 'success' }; return n; });
          setRetryIdx(null); setRetryJobId(null);
        }
      }, [retryStream?.status]);

      const toggleClip = (i) => setDeselected(prev => { const n=new Set(prev); n.has(i)?n.delete(i):n.add(i); return n; });
      const selectedCount = suggestions.length - deselected.size;
      const handleLogoUpload = async (f) => {
        setLogoUploading(true);
        try { const d = await uploadFile(f, ()=>{}); if(d.file_path) setLogoPath(d.file_path); }
        catch(e) { setError('Logo upload failed'); }
        finally { setLogoUploading(false); }
      };
      const handleOutroUpload = async (f) => {
        setOutroUploading(true);
        try { const d = await uploadFile(f, ()=>{}); if(d.file_path) setOutroPath(d.file_path); }
        catch(e) { setError('Outro upload failed'); }
        finally { setOutroUploading(false); }
      };
      const buildLocalPrompt = () => {
        const parts = [];
        const hasTranscriptReady = transcript || transcriptText.trim();
        if (transcriptMode === 'whisper' && !hasTranscriptReady) {
          parts.push(`Transcribe the podcast at ${videoPath} using transcribe_podcast with model_size="${whisperModel}".`);
          parts.push('Then find the 5-8 best viral-worthy moments and call suggest_clips.');
        } else {
          parts.push('Use get_ui_state with include_transcript=true to read the full transcript.');
          parts.push('Find the 5-8 best viral-worthy moments — hot takes, strong opinions, funny moments, actionable advice, and emotional stories.');
          parts.push('Then call suggest_clips with your suggestions.');
        }
        const settings = [];
        if (videoPath) settings.push(`Video: ${videoPath.split('/').pop()}`);
        settings.push(`Style: ${captionStyle}`);
        settings.push(`Crop: ${cropStrategy}`);
        if (logoPath) settings.push(`Logo: set`);
        if (outroPath) settings.push(`Outro: set`);
        parts.push(`Current settings: ${settings.join(', ')}`);
        return parts.join('\n');
      };

      const copyGeneratePrompt = async () => {
        // If user has pasted a transcript but it hasn't been parsed yet, parse it first
        if (transcriptMode === 'import' && transcriptText.trim() && !transcript) {
          setError(null);
          setPhase('parsing');
          const fileData = await api('/select-file', { method:'POST', body: JSON.stringify({ file_path: videoPath.trim() }) });
          if (fileData.error) { setError(fileData.error); setPhase('idle'); return; }
          setFile(fileData);
          const text = transcriptText.trim();
          const isJson = text.startsWith('{') || text.startsWith('[');
          let t = null;
          if (isJson) {
            const parsed = JSON.parse(text);
            const tr = Array.isArray(parsed) ? { words: parsed } : parsed;
            const data = await api('/import-transcript', { method:'POST', body: JSON.stringify({ file_path: videoPath.trim(), transcript: tr }) });
            if (data.error) { setError(data.error); setPhase('idle'); return; }
            t = data.data;
          } else {
            const data = await api('/parse-transcript', { method:'POST', body: JSON.stringify({ file_path: videoPath.trim(), raw_text: text, time_adjust: timeAdjust }) });
            if (data.error) { setError(data.error); setPhase('idle'); return; }
            t = data.data;
          }
          setTranscript(t);
          // Sync transcript + video to server immediately (don't wait for React useEffect)
          await fetch('/api/ui-state', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ _source: 'ui', transcript: t, videoPath: videoPath.trim(), filePath: fileData.file_path }),
          }).catch(() => {});
          setPhase('idle');
        }

        // Ensure video path is synced even without transcript parsing
        if (videoPath.trim()) {
          await fetch('/api/ui-state', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              _source: 'ui',
              videoPath: videoPath.trim(),
              rawTranscriptText: transcriptText.trim() || undefined,
              settings: { captionStyle, cropStrategy, logoPath, outroPath },
            }),
          }).catch(() => {});
        }

        let prompt;
        try {
          const res = await fetch('/api/generate-prompt', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'suggest' }),
          });
          const data = await res.json();
          prompt = data.prompt || buildLocalPrompt();
        } catch {
          prompt = buildLocalPrompt();
        }
        navigator.clipboard.writeText(prompt).then(() => {
          setGenerateCopied(true);
          setTimeout(() => setGenerateCopied(false), 2000);
        }).catch(() => {});
      };

      const isProcessing = phase === 'parsing' || phase === 'suggesting' || phase === 'exporting';
      const selectedClips = suggestions.filter((_,i) => !deselected.has(i));

      const getExportStatus = (resultIdx) => {
        if (phase !== 'exporting' || !batchStream) return null;
        const total = selectedClips.length; if (!total) return null;
        const pct = batchStream.progress || 0;
        const done = Math.floor(pct / (100 / total));
        if (resultIdx < done) return 'exported';
        if (resultIdx === done && pct < 100) return 'rendering';
        return 'pending';
      };

      const handleVideoDrop = (e) => { e.preventDefault(); };
      const handleTranscriptDrop = (e) => { e.preventDefault(); setTranscriptDragOver(false); const files = e.dataTransfer?.files; if(!files?.length) return; const f=files[0]; setTranscriptFileName(f.name); const reader=new FileReader(); reader.onload=(ev)=>setTranscriptText(ev.target.result); reader.readAsText(f); };
      const handleTranscriptFileSelect = (e) => { const f=e.target.files?.[0]; if(!f) return; setTranscriptFileName(f.name); const reader=new FileReader(); reader.onload=(ev)=>setTranscriptText(ev.target.result); reader.readAsText(f); };
      const preventDef = (e) => e.preventDefault();

      const activeClip = activeClipIdx !== null ? suggestions[activeClipIdx] : null;

      return (
        <div className="app">
          <div className="header">
            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
              <img src="/podcli-logo-transparent.png" alt="podcli" style={{ height: 22 }} />
              <div style={{ display:'flex', alignItems:'center', gap: 8 }}>
                {mcpConnected && (
                  <span className="pill" style={{ fontSize:10, letterSpacing:'0.5px', background:'var(--green-subtle)', color:'var(--green)', border:'1px solid var(--green-border)' }}>
                    MCP linked
                  </span>
                )}
                {encoderInfo && (
                  <span className="pill pill-blue" style={{ fontSize:10, letterSpacing:'0.5px' }}>
                    {encoderInfo.best === 'libx264' ? 'CPU' : encoderInfo.best.replace('h264_','').toUpperCase()}
                  </span>
                )}
                <a href="/knowledge.html" style={{ fontSize:12, fontWeight:600, color:'var(--text2)', textDecoration:'none', padding:'5px 12px', border:'1px solid var(--border)', borderRadius:'var(--radius-sm)', transition:'all 0.15s' }}>Knowledge</a>
                <a href="/integration.html" style={{ fontSize:12, fontWeight:600, color:'var(--text2)', textDecoration:'none', padding:'5px 12px', border:'1px solid var(--border)', borderRadius:'var(--radius-sm)', transition:'all 0.15s' }}>MCP Setup</a>
              </div>
            </div>
            <h1>Create short-form clips</h1>
          </div>

          <div className="layout">
            {/* ═══════════ LEFT COLUMN ═══════════ */}
            <div className="main-col">

              {/* Video */}
              <div className="section">
                <div className="section-label">Video</div>
                {!videoPath && (
                  <div className="drop-zone" style={{cursor:'pointer'}} onClick={browsing||isProcessing ? undefined : doBrowse}
                    onDragOver={preventDef} onDrop={handleVideoDrop}>
                    {browsing ? (
                      <div style={{display:'flex',alignItems:'center',gap:10}}>
                        <div className="spinner sm" />
                        <div style={{fontSize:13,fontWeight:600}}>Waiting for file selection{'\u2026'}</div>
                      </div>
                    ) : (
                      <>
                        <div className="icon">{'\uD83C\uDFAC'}</div>
                        <div className="label"><strong>Browse</strong> to select a video file</div>
                      </>
                    )}
                  </div>
                )}
                {videoPath && (
                  <div className="file-badge fade-in">
                    <div className="dot" />
                    <div className="name">{videoPath.split('/').pop()}</div>
                    <button className="btn btn-ghost btn-sm" onClick={()=>setVideoPath('')} style={{padding:'4px 10px',fontSize:11}}>Clear</button>
                  </div>
                )}
                <input type="text" placeholder="Or paste a local path: /Users/you/episode.mp4"
                  value={videoPath} onChange={e=>setVideoPath(e.target.value)}
                  disabled={isProcessing||browsing}
                  style={{ marginTop:8, fontSize:12, padding:'9px 13px', background:'var(--bg)', borderColor: videoPath?'var(--green-border)':'var(--border)' }} />
              </div>

              {/* Transcript */}
              <div className="section">
                <div className="section-label">Transcript</div>
                <div className="tabs">
                  <div className={`tab ${transcriptMode==='import'?'active':''}`} onClick={()=>setTranscriptMode('import')}>Paste Transcript</div>
                  <div className={`tab ${transcriptMode==='whisper'?'active':''}`} onClick={()=>setTranscriptMode('whisper')}>Auto (Whisper)</div>
                </div>
                {transcriptMode === 'import' && (
                  <div className="fade-in">
                    {!transcriptText && (
                      <div className={`drop-zone ${transcriptDragOver?'drag-over':''}`}
                        onDragOver={e=>{preventDef(e);setTranscriptDragOver(true);}} onDragLeave={()=>setTranscriptDragOver(false)}
                        onDrop={handleTranscriptDrop} style={{marginBottom:10,padding:'22px 20px'}}>
                        <div className="icon">{'\uD83D\uDCC4'}</div>
                        <div className="label">Drop a transcript file or <strong>browse</strong></div>
                        <input type="file" accept=".txt,.json,.srt,.vtt" onChange={handleTranscriptFileSelect} disabled={isProcessing} />
                      </div>
                    )}
                    {transcriptText && transcriptFileName && (
                      <div className="file-badge fade-in" style={{marginBottom:10}}>
                        <div className="dot"/><div className="name">{transcriptFileName}</div>
                        <div className="meta">{transcriptText.split('\n').length} lines</div>
                        <button className="btn btn-ghost btn-sm" onClick={()=>{setTranscriptText('');setTranscriptFileName('');}} style={{padding:'4px 10px',fontSize:11}}>Clear</button>
                      </div>
                    )}
                    <textarea placeholder={'Speaker (00:00)\nText of what they said...\n\nSpeaker2 (00:15)\nMore text...\n\n— or paste JSON / drag a .txt file above —'}
                      value={transcriptText} onChange={e=>{setTranscriptText(e.target.value);setTranscriptFileName('');}}
                      disabled={isProcessing} style={{minHeight:transcriptText?80:120}}
                      onDragOver={e=>{preventDef(e);setTranscriptDragOver(true);}} onDrop={handleTranscriptDrop} />
                    <div style={{display:'flex',gap:8,alignItems:'center',marginTop:10}}>
                      <span style={{fontSize:12,color:'var(--text2)',whiteSpace:'nowrap'}}>Time offset</span>
                      <input type="number" step="0.5" value={timeAdjust} onChange={e=>setTimeAdjust(parseFloat(e.target.value)||0)}
                        style={{width:72,padding:'7px 10px',fontSize:12}} disabled={isProcessing} />
                      <span style={{fontSize:11,color:'var(--text3)'}}>sec</span>
                    </div>
                  </div>
                )}
                {transcriptMode === 'whisper' && (
                  <div className="fade-in"><div className="row"><div>
                    <label className="field-label">Model</label>
                    <select value={whisperModel} onChange={e=>setWhisperModel(e.target.value)} disabled={isProcessing}>
                      <option value="tiny">Tiny (fastest)</option><option value="base">Base</option>
                      <option value="small">Small</option><option value="medium">Medium</option>
                      <option value="large">Large (best)</option>
                    </select>
                  </div></div></div>
                )}
              </div>

              {/* Settings */}
              <div className="section">
                <div className="section-label">Settings</div>
                <div className="settings-grid">
                  <div>
                    <label className="field-label">Caption Style</label>
                    <select value={captionStyle} onChange={e=>onCaptionChange(e.target.value)} disabled={isProcessing}>
                      <option value="branded">Branded</option><option value="hormozi">Hormozi</option>
                      <option value="karaoke">Karaoke</option><option value="subtle">Subtle</option>
                    </select>
                  </div>
                  <div>
                    <label className="field-label">Crop</label>
                    <select value={cropStrategy} onChange={e=>onCropChange(e.target.value)} disabled={isProcessing}>
                      <option value="center">Center</option><option value="face">Face Detection</option>
                    </select>
                  </div>
                </div>
                <div style={{display:'flex',gap:8,flexWrap:'wrap'}}>
                  {captionStyle === 'branded' && (
                    logoPath ? (
                      <div className="asset-pill fade-in">
                        <span className="asset-pill-icon">
                          <img src={`/api/stream-source?path=${encodeURIComponent(logoPath)}`}
                            style={{width:16,height:16,objectFit:'contain',borderRadius:3}} onError={e=>{e.target.style.display='none'}} />
                        </span>
                        <span className="asset-pill-name">{logoPath.split('/').pop()}</span>
                        <button className="asset-pill-x" onClick={()=>setLogoPath('')} disabled={isProcessing}>{'\u00D7'}</button>
                      </div>
                    ) : (
                      <button className="asset-add fade-in" onClick={()=>logoRef.current?.click()} disabled={isProcessing||logoUploading}>
                        {logoUploading ? <div className="spinner sm"/> : '+'} Logo
                      </button>
                    )
                  )}
                  {outroPath ? (
                    <div className="asset-pill">
                      <span className="asset-pill-icon" style={{fontSize:11}}>{'▶'}</span>
                      <span className="asset-pill-name">{outroPath.split('/').pop()}</span>
                      <button className="asset-pill-x" onClick={()=>setOutroPath('')} disabled={isProcessing}>{'\u00D7'}</button>
                    </div>
                  ) : (
                    <button className="asset-add" onClick={()=>outroRef.current?.click()} disabled={isProcessing||outroUploading}>
                      {outroUploading ? <div className="spinner sm"/> : '+'} Outro
                    </button>
                  )}
                  <input ref={logoRef} type="file" accept=".png,.jpg,.jpeg,.svg" style={{display:'none'}}
                    onChange={e=>e.target.files[0]&&handleLogoUpload(e.target.files[0])} />
                  <input ref={outroRef} type="file" accept=".mp4,.mov,.mkv,.webm" style={{display:'none'}}
                    onChange={e=>e.target.files[0]&&handleOutroUpload(e.target.files[0])} />
                </div>
              </div>

              {/* Error */}
              {error && (
                <div className="error-bar fade-in">
                  <span>{error}</span>
                  <button className="btn btn-ghost btn-sm" onClick={()=>setError(null)} style={{flexShrink:0,color:'var(--red)',borderColor:'var(--red-border)'}}>Dismiss</button>
                </div>
              )}

              {/* Generate */}
              {phase === 'idle' && (
                <div>
                  <button className="btn btn-go"
                    disabled={!videoPath.trim()||(transcriptMode==='import'&&!transcriptText.trim())||browsing}
                    onClick={copyGeneratePrompt}
                    style={generateCopied ? {background:'var(--green)',transition:'background 0.2s'} : {}}>
                    {generateCopied ? 'Copied — paste in Claude' : 'Generate Clips'}
                  </button>
                  {videoPath.trim() && (transcriptText.trim() || transcript) && (
                    <McpHints phase={phase} videoPath={videoPath} transcript={transcript} transcriptText={transcriptText} suggestions={suggestions} mcpConnected={mcpConnected} />
                  )}
                </div>
              )}

              {/* Parsing */}
              {phase === 'parsing' && (
                <div className="fade-in" style={{marginTop:20}}>
                  <div className="status-line"><span style={{display:'flex',alignItems:'center',gap:8}}><div className="spinner sm"/>Processing transcript{'\u2026'}</span></div>
                  <div className="progress-track"><div className="progress-fill indeterminate"/></div>
                </div>
              )}

              {/* Suggesting (no clips yet) */}
              {phase === 'suggesting' && suggestions.length === 0 && (
                <div className="fade-in" style={{marginTop:20}}>
                  <div className="status-line"><span style={{display:'flex',alignItems:'center',gap:8}}><div className="spinner sm"/>Analyzing transcript{'\u2026'}</span></div>
                  <div className="progress-track"><div className="progress-fill indeterminate"/></div>
                </div>
              )}

              {/* Clip list */}
              {(phase==='suggesting'||phase==='review'||phase==='exporting'||phase==='done') && suggestions.length > 0 && (
                <div>
                  <div className="spacer" />
                  <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:14}}>
                    <div className="section-label" style={{margin:0,display:'flex',alignItems:'center',gap:8}}>
                      {phase === 'suggesting' && <div className="spinner sm"/>}
                      {phase==='suggesting' ? `Found ${suggestions.length} clip${suggestions.length!==1?'s':''}`
                        : phase==='review' ? `Clips \u00B7 ${selectedCount} selected` : 'Clips'}
                    </div>
                    <div style={{display:'flex',gap:6,alignItems:'center'}}>
                      {phase === 'review' && (
                        <button className="btn btn-primary btn-sm" disabled={selectedCount===0} onClick={startExport}>
                          Export {selectedCount} clip{selectedCount!==1?'s':''}
                        </button>
                      )}
                      {transcript && (phase === 'review' || phase === 'done') && (
                        <div style={{position:'relative'}}>
                          <button className="btn btn-ghost btn-sm overflow-menu-btn" onClick={e=>{const m=e.currentTarget.nextElementSibling;m.style.display=m.style.display==='block'?'none':'block';}} style={{padding:'4px 8px',fontSize:14,color:'var(--text3)',lineHeight:1}}>
                            {'\u22EF'}
                          </button>
                          <div className="overflow-menu" style={{display:'none'}}>
                            <div className="overflow-menu-label">Export transcript</div>
                            {['SRT','VTT','JSON'].map(fmt => (
                              <button key={fmt} className="overflow-menu-item" onClick={e=>{window.open(`/api/export-transcript?format=${fmt.toLowerCase()}`,'_blank');e.currentTarget.closest('.overflow-menu').style.display='none';}}>
                                {fmt}
                              </button>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>

                  {suggestions.map((clip, i) => {
                    const off = deselected.has(i);
                    const resultIdx = [...suggestions.keys()].filter(k=>!deselected.has(k)).indexOf(i);
                    const r = results[resultIdx];
                    const outputFile = r?.output_path?.split('/').pop();
                    const failed = r?.status === 'error';
                    const isRetryingThis = retryIdx === resultIdx;
                    const exportStatus = !off ? getExportStatus(resultIdx) : null;
                    const isSelected = activeClipIdx === i && !previewSrc;

                    return (
                      <div key={i}
                        className={`clip-item ${off&&phase==='review'?'dimmed':''} ${exportStatus==='rendering'?'active-clip':''} ${phase==='suggesting'?'clip-reveal':''} ${isSelected?'selected':''}`}
                        onClick={() => onClipClick(i)}>

                        {phase === 'review' && (
                          <div className={`checkbox ${!off?'checked':''}`} onClick={(e)=>{e.stopPropagation();toggleClip(i);}}>
                            {!off && <CheckIcon/>}
                          </div>
                        )}

                        {phase === 'exporting' && !off && exportStatus && (
                          <div className={`clip-status ${exportStatus}`}>{exportStatus==='exported'&&<CheckSmall/>}</div>
                        )}

                        {phase === 'done' && !off && r && (
                          <div className={`status-dot ${failed?'fail':'ok'}`}>{failed?'\u00D7':'\u2713'}</div>
                        )}

                        <div className="clip-info">
                          <div className="clip-title">{clip.title}</div>
                          <div className="clip-meta">
                            {fmt(clip.start_second)} {'\u2192'} {fmt(clip.end_second)} {'\u00B7'} {clip.duration}s
                            {r&&!failed&&<span> {'\u00B7'} {r.file_size_mb}MB</span>}
                            {failed&&<span className="err"> {'\u00B7'} {r.error?.slice(0,60)}</span>}
                            {exportStatus==='rendering'&&<span style={{color:'var(--accent)'}}> {'\u00B7'} rendering{'\u2026'}</span>}
                          </div>
                        </div>

                        {phase === 'done' && !off && r && !failed && outputFile && (
                          <div className="clip-actions" onClick={e=>e.stopPropagation()}>
                            <button className="btn btn-ghost btn-sm" onClick={()=>onPlayRendered(outputFile)} title="Preview">{'\u25B6'}</button>
                            <a href={`/api/download/${outputFile}`} className="btn btn-primary btn-sm" download title="Download">{'\u2193'}</a>
                            <button className="btn btn-ghost btn-sm" disabled={isRetryingThis} onClick={()=>retryClip(resultIdx)} title="Retry">{'\u21BB'}</button>
                          </div>
                        )}
                        {phase === 'done' && !off && r && failed && (
                          <button className="btn btn-ghost btn-sm" onClick={e=>{e.stopPropagation();retryClip(resultIdx);}} disabled={isRetryingThis}>
                            {isRetryingThis?'\u2026':'Retry'}
                          </button>
                        )}
                      </div>
                    );
                  })}

                  {phase === 'exporting' && batchStream && (
                    <div style={{marginTop:14}}>
                      <div className="status-line">
                        <span>{batchStream.message}</span>
                        <span style={{fontWeight:600,fontVariantNumeric:'tabular-nums'}}>{batchStream.progress||0}%</span>
                      </div>
                      <div className="progress-track"><div className="progress-fill" style={{width:`${batchStream.progress||0}%`}}/></div>
                    </div>
                  )}

                  {retryIdx !== null && retryStream?.status === 'running' && (
                    <div style={{marginTop:10,padding:12,background:'var(--surface)',borderRadius:'var(--radius-sm)'}}>
                      <div className="status-line" style={{fontSize:12}}>
                        <span style={{display:'flex',alignItems:'center',gap:6}}><div className="spinner sm"/>Retrying{'\u2026'}</span>
                        <span style={{fontWeight:600}}>{retryStream.progress||0}%</span>
                      </div>
                      <div className="progress-track"><div className="progress-fill" style={{width:`${retryStream.progress||0}%`}}/></div>
                    </div>
                  )}

                  {(phase === 'done' || phase === 'review' || phase === 'exporting') && (
                    <div style={{display:'flex',gap:10,justifyContent:'center',marginTop:24}}>
                      <button className="btn btn-ghost" onClick={()=>{setPhase('idle');setResults([]);setSuggestions([]);setBatchJobId(null);setFile(null);setTranscript(null);setActiveClipIdx(null);setPreviewSrc(null);
                        fetch('/api/ui-state',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({_source:'ui',phase:'idle',suggestions:[],deselectedIndices:[]})}).catch(()=>{});
                      }}>Start Over</button>
                      {phase === 'done' && <button className="btn btn-ghost" onClick={()=>{setPhase('review');setResults([]);setBatchJobId(null);}}>Re-export</button>}
                    </div>
                  )}
                  {(phase === 'review' || phase === 'done') && (
                    <McpHints phase={phase} videoPath={videoPath} transcript={transcript} transcriptText={transcriptText} suggestions={suggestions} mcpConnected={mcpConnected} />
                  )}
                </div>
              )}
              {/* ═══════════ CLIP HISTORY ═══════════ */}
              {clipHistory.length > 0 && (
                <div className="section" style={{marginTop:16}}>
                  <div className="section-label" style={{cursor:'pointer',userSelect:'none',display:'flex',justifyContent:'space-between',alignItems:'center'}}
                    onClick={()=>setHistoryOpen(!historyOpen)}>
                    <span>History ({clipHistory.length})</span>
                    <span style={{fontSize:10,color:'var(--text3)',transition:'transform 0.2s',transform:historyOpen?'rotate(180deg)':'rotate(0)'}}>{'\u25BC'}</span>
                  </div>
                  {historyOpen && (
                    <div className="fade-in" style={{display:'flex',flexDirection:'column',gap:4,maxHeight:300,overflowY:'auto',marginTop:8}}>
                      {clipHistory.map((c,i) => {
                        const date = new Date(c.created_at);
                        const ago = ((Date.now() - date.getTime()) / 3600000);
                        const timeStr = ago < 1 ? `${Math.round(ago*60)}m ago` : ago < 24 ? `${Math.round(ago)}h ago` : date.toLocaleDateString();
                        const fname = c.output_path?.split('/').pop() || c.title;
                        return (
                          <div key={c.id||i} style={{display:'flex',alignItems:'center',gap:8,padding:'8px 10px',background:'var(--surface)',borderRadius:'var(--radius-sm)',fontSize:12,cursor:'pointer'}}
                            onClick={()=>{ const f=c.output_path?.split('/').pop(); if(f) setPreviewSrc(f); }}>
                            <div style={{width:6,height:6,borderRadius:3,background:'var(--green)',flexShrink:0}}/>
                            <div style={{flex:1,minWidth:0}}>
                              <div style={{fontWeight:600,overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap'}}>{c.title || fname}</div>
                              <div style={{color:'var(--text3)',fontSize:11,marginTop:2}}>
                                {c.duration}s {'\u00B7'} {c.file_size_mb?.toFixed(1)}MB {'\u00B7'} {c.caption_style} {'\u00B7'} {timeStr}
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* ═══════════ RIGHT COLUMN — PREVIEW ═══════════ */}
            <div className="preview-col">
              <div className="preview-panel">

                {/* Video player (when video loaded) */}
                {videoUrl && (
                  <div className="preview-player fade-in" style={{ marginBottom: 12 }}>
                    <video
                      key={videoUrl}
                      ref={videoRef}
                      src={videoUrl}
                      controls
                      preload="auto"
                      className={previewSrc ? 'vertical' : ''}
                    />
                    {activeClip && !previewSrc && (
                      <div className="preview-clip-range">
                        <span className="clip-name">{activeClip.title}</span>
                        <span>{fmt(activeClip.start_second)} {'\u2192'} {fmt(activeClip.end_second)}</span>
                      </div>
                    )}
                    {previewSrc && (
                      <div className="preview-clip-range">
                        <span className="clip-name">Rendered clip</span>
                        <button className="preview-back" onClick={()=>setPreviewSrc(null)}>Back to source</button>
                      </div>
                    )}
                  </div>
                )}

                {/* Style preview mockup — hidden when rendered clip is playing */}
                {!previewSrc && <StylePreview style={captionStyle} logoPath={logoPath} />}

                {/* Settings tags */}
                <div className="preview-settings">
                  <div className={`preview-tag ${settingsFlash==='caption'?'changed':''}`}
                    style={settingsFlash==='caption'?{animation:'tagFlash 0.6s var(--ease)'}:{}}>
                    Caption {'\u00B7'} <strong>{captionStyle}</strong>
                  </div>
                  <div className={`preview-tag ${settingsFlash==='crop'?'changed':''}`}
                    style={settingsFlash==='crop'?{animation:'tagFlash 0.6s var(--ease)'}:{}}>
                    Crop {'\u00B7'} <strong>{cropStrategy}</strong>
                  </div>
                  {logoPath && (
                    <div className="preview-tag">
                      Logo {'\u00B7'} <strong>{logoPath.split('/').pop()}</strong>
                    </div>
                  )}
                  {outroPath && (
                    <div className="preview-tag">
                      Outro {'\u00B7'} <strong>{outroPath.split('/').pop()}</strong>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Modal (mobile fallback) */}
          {previewFile && (
            <div className="modal-overlay" onClick={()=>setPreviewFile(null)}>
              <div className="modal-body" onClick={e=>e.stopPropagation()}>
                <video src={`/api/preview/${previewFile}`} controls autoPlay />
                <div style={{textAlign:'center',marginTop:12}}>
                  <button className="btn btn-ghost btn-sm" onClick={()=>setPreviewFile(null)}>Close</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
